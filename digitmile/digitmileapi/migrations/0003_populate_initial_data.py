# Generated by Django an unknown version on 2024-05-26 10:38

from django.db import migrations
from django.contrib.auth.hashers import make_password # To create passwords for users

def create_initial_data(apps, schema_editor):
    User = apps.get_model('auth', 'User')
    Group = apps.get_model('auth', 'Group') # To add teachers to 'Teachers' group
    School = apps.get_model('digitmileapi', 'School')
    Teacher = apps.get_model('digitmileapi', 'Teacher')
    Classroom = apps.get_model('digitmileapi', 'Classroom')

    # --- Create Schools ---
    school1, created_s1 = School.objects.get_or_create(
        name="Springfield Elementary",
        defaults={'municipality': "Springfield"}
    )
    school2, created_s2 = School.objects.get_or_create(
        name="Shelbyville High",
        defaults={'municipality': "Shelbyville"}
    )

    # --- Get 'Teachers' group ---
    # Ensure the group exists (it should have been created by the apps.py signal)
    try:
        teachers_group = Group.objects.get(name='Teachers')
    except Group.DoesNotExist:
        # Fallback: create it if it somehow wasn't created by the signal
        teachers_group = Group.objects.create(name='Teachers')
        print("Warning: 'Teachers' group was not found and had to be created by migration 0003.")
        # Note: Permissions would ideally be set by the signal.
        # If this fallback is hit, permissions might not be fully configured for the group
        # until the signal runs again or they are set manually.

    # --- Create Teachers (User and Teacher profile) ---
    # Teacher 1
    user_teacher1, created_ut1 = User.objects.get_or_create(
        username="edna.krabappel",
        defaults={
            'first_name': "Edna",
            'last_name': "Krabappel",
            'email': "edna@springfieldelementary.com",
            'password': make_password("password123"), # Use a secure password in real scenarios
            'is_staff': True # Teachers are not typically staff unless they need admin access
        }
    )
    if created_ut1:
        user_teacher1.groups.add(teachers_group)

    teacher1, created_t1 = Teacher.objects.get_or_create(
        user=user_teacher1,
        defaults={
            'full_name': "Edna Krabappel", # Consider deriving from user or removing this field
            'school': school1
        }
    )

    # Teacher 2
    user_teacher2, created_ut2 = User.objects.get_or_create(
        username="dewey.finn",
        defaults={
            'first_name': "Dewey",
            'last_name': "Finn",
            'email': "dewey@shelbyvillehigh.com",
            'password': make_password("rockon456"),
            'is_staff': True
        }
    )
    if created_ut2:
        user_teacher2.groups.add(teachers_group)
        
    teacher2, created_t2 = Teacher.objects.get_or_create(
        user=user_teacher2,
        defaults={
            'full_name': "Dewey Finn",
            'school': school2
        }
    )
    
    # --- Create Classrooms ---
    # Classroom for Teacher 1
    classroom1, created_c1 = Classroom.objects.get_or_create(
        classroom_key="SPGFLD-4TH-MATH",
        defaults={'teacher': teacher1}
    )

    # Classroom for Teacher 2
    classroom2, created_c2 = Classroom.objects.get_or_create(
        classroom_key="SHLBVL-MUSC-101",
        defaults={'teacher': teacher2}
    )
    
    # Classroom for Teacher 1 (another one)
    classroom3, created_c3 = Classroom.objects.get_or_create(
        classroom_key="SPGFLD-4TH-ENG",
        defaults={'teacher': teacher1}
    )

    print("Initial data population complete (Schools, Teachers, Classrooms).")


def remove_initial_data(apps, schema_editor):
    # This is a simple reverse. More complex scenarios might need more care.
    # It's often okay for initial data migrations to have a no-op reverse
    # or a very specific deletion if the data is clearly identifiable.
    User = apps.get_model('auth', 'User')
    School = apps.get_model('digitmileapi', 'School')
    Classroom = apps.get_model('digitmileapi', 'Classroom')

    User.objects.filter(username__in=["edna.krabappel", "dewey.finn"]).delete()
    # Teacher profiles will be cascade deleted due to OneToOneField with User.
    
    School.objects.filter(name__in=["Springfield Elementary", "Shelbyville High"]).delete()
    # Classrooms linked to the deleted teachers/schools might also be cascade deleted
    # depending on on_delete settings. Let's be explicit for classrooms created by key.
    Classroom.objects.filter(classroom_key__in=["SPGFLD-4TH-MATH", "SHLBVL-MUSC-101", "SPGFLD-4TH-ENG"]).delete()
    
    print("Initial data removal complete.")


class Migration(migrations.Migration):

    dependencies = [
        ('digitmileapi', '0002_teacher_user'), # Ensure this matches your previous migration
        # Add dependency on auth app if not implicitly handled, for Group model
        ('auth', '0001_initial'), # Or whatever your latest auth migration is. Usually not needed explicitly for get_model.
    ]

    operations = [
        migrations.RunPython(create_initial_data, reverse_code=remove_initial_data),
    ]
